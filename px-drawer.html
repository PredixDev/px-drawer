<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<script src="../hammerjs/hammer.min.js"></script>

<!--
`px-drawer` is a navigation drawer that can slide in from the left, right, top or bottom.

<link href="../iron-overlay-behavior/iron-overlay-behavior.html" rel="import">
<p>
  For demo visit <a href="demo.html" target="_blank">Full demo here</a> or <a href="mobile-demo.html" target="_blank">Mobile demo here</a>
</p>

### Example

```
<div class="box">
  <style>
    body {
      --px-drawer-background-color: #555;
    }
  </style>
  <px-drawer id="drawer1" align="left">
    <p class="u-m">
      This is content inside of the drawer
    </p>
  </px-drawer>
  <button class="btn btn--full" onclick="document.getElementById('drawer1').toggle()">
    Toggle
  </button>
</div>
```

### Styling

Custom property | Description | Default
------------ | ------------- | ------------
`--px-drawer`   | Style mixin to be applied to the element | {}
`--px-drawer-content`   | Style mixin to be applied to the content | {}
`--px-drawer-background-color` | The background-color of the drawer  |  `#242326` *(gray10)*
`--px-drawer-width` | The width of the drawer | `256px`
`--px-drawer-height` | The height of the drawer | `100vh`
`--px-drawer-overlay-background` | The background color of the overlay | `rgba(0, 0, 0, 0.5))`

@element px-drawer.html
@blurb px-drawer A responsive drawer.
@demo demo.html
@demo mobile-demo.html
@homepage index.html
-->
<dom-module id="px-drawer">
  <link rel="import" type="css" href="css/px-drawer.css">
  <!-- <link rel="stylesheet" href="css/px-drawer.css"> -->
  <style>
    :host {
      }

    :host([opened]) {
      }

    :host .drawer {
      background-color: (--px-drawer-background-color, #242326);
      width: (--px-drawer-width, 256px);
      @apply(--px-drawer);
    }

    :host .drawer__content {
      @apply(--px-drawer-content);
    }

    :host([swipe-open]) > .drawer::after {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 100%;
      visibility: visible;
      width: 20px;
      content: '';
    }

    :host .drawer__overlay {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      transition: opacity 0.2s ease;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      opacity: 0;
      background: var(--px-drawer-overlay-background, rgba(0, 0, 0, 0.5));
      z-index: -1;
      visibility: hidden;
    }

    :host([opened][overlay]) > .drawer__overlay {
      opacity: 1;
      z-index: 201;
      visibility: visible;
    }
    :host([opened][persistent]) > .drawer__overlay {
      visibility: hidden;
      opacity: 0;
    }

  </style>
  <template>
    <div id="overlay" class="drawer__overlay" on-tap="toggle" hidden="{{!overlay}}"></div>
    <div id="drawer" class="drawer">
      <div id="drawerContent" class="drawer__content">
        <content id="contentContainer" select="*"></content>
      </div>
    </div>
  </template>
  <script>
    Polymer({
      is: 'px-drawer',
      behaviors: [Polymer.IronResizableBehavior],
      properties: {
        /**
         * The state of the drawer
         */
        opened: {
          type: Boolean,
          value: false,
          notify: true,
          reflectToAttribute: true,
          observer: '_openHandler'
        },
        /**
       * The drawer is persistent and cannot be closed.
       */
        persistent: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
         * To position the drawer in fixed mode.
         */
        fixed: {
          type: Boolean,
          value: false
        },
        /**
         * Enable overlay when drawer is opened.
         */
        overlay: {
          type: Boolean
        },
        /**
         * The theme to apply to the drawer (`dark`)
         * @default transparent
         */
        theme: {
          type: String,
          reflectToAttribute: true
        },
        /**
         * The alignment of the drawer on the screen (`left`, `right`, `top`, `bottom`)
         */
        align: {
          type: String,
          reflectToAttribute: true,
          value: 'left',
          observer: '_typeHandler'
        },
        /**
         * The type of drawer (`temporary`, `persistent`, `mini`)
         */
        type: {
          type: String,
          value: 'temporary',
          reflectToAttribute: true,
          observer: '_typeHandler'
        },
        /**
        * Create an area at the edge of the screen to swipe open the drawer.
        */
        swipeOpen: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        },
        swipeClose: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        }
      },
      listeners: {
        'overlay.tap': 'toggle',
        'iron-resize': '_resizeHandler'
      },
      observers: ['resetLayout(isAttached, condenses, fixed)'],
      _boundEscKeydownHandler: null,
      ready: function () {
        this.setScrollDirection('y');


        var mc = new Hammer(this.$.drawer);

        // listen to events...
        mc.on("panleft panup panright pandown", this._handlePan.bind(this));
      },
      _handlePan: function(e){
        this._moveDrawer(e.deltaX);
        switch (e.type) {
          case 'panup':
            if(this.align === 'bottom'){
              this.open();
            }
            break;
          case 'pandown':
            if(this.align === 'bottom'){
              this.close();
            }
            break;
          case 'panleft':
            if(this.align === 'left'){
              this.close();
            }
            break;
          case 'panright':
            this.open();
            break;
          default:

        }
      //  console.log(e,  e.type +" gesture detected.");
      },
      attached: function () {
        Polymer.RenderStatus.afterNextRender(this, function () {
          document.addEventListener('keydown', this._escKeydownHandler.bind(this));

        });

        this.toggleClass('drawer--' + this.align, true, this.$.drawer);

        if (this.theme) {
          this.toggleClass('drawer--' + this.theme, true, this.$.drawer);
        }
        if (this.fixed) {
          this.toggleClass('drawer--fixed', true, this.$.drawer);
        }
        if (this.persistent) {
          this.toggleClass('drawer--temporary', true, this.$.drawer);
          this.toggleClass('drawer--persistent', true, this.$.drawer);
        }
      },
      detached: function () {
        document.removeEventListener('keydown', this._boundEscKeydownHandler);
      },
      /**
        * Handle toggling the drawer open or close.
        * @event px-drawer-toggle
        */
      toggle: function (type) {
        this.opened = !this.opened;
        this.fire('px-drawer-toggle', this.opened);
      },
      /**
       * Handle when a click is outside the drawer.
       */
      _handleOffClick: function (e) {
        if (this.opened) {
          this.close();
        }
      },
      /**
       * Handle when the drawer opened state is changed.
       */
      _openHandler: function (newVal, oldVal) {
        this.toggleClass('is-open', newVal, this.$.drawer);
        this.toggleClass('is-open', newVal, this.$.overlay);
      },
      /**
       * Handle when the drawer type is changed.
       */
      _typeHandler: function (newVal, oldVal) {
        this.toggleClass('drawer--' + oldVal, false, this.$.drawer);
        this.toggleClass('drawer--' + newVal, true, this.$.drawer);
        if (this.persistent) {
          //  this.toggleClass('drawer--temporary');
        }
      },
      /**
     * Gets the width of the drawer.
     *
     * @return {Number} The width of the drawer in pixels.
     */
      getWidth: function () {
        return this.$.drawerContent.offsetWidth;
      },
      /**
       * Opens the drawer.
       * @event px-drawer-open
       */
      open: function () {
        if(!this.persistent){
          this.opened = true;
          this.fire('px-drawer-open', this);
        }

      },
      /**
       * Closes the drawer.
       * @event px-drawer-close
       */
      close: function () {
        if(!this.persistent){
          this.opened = false;
          this.fire('px-drawer-close', this);
        }

      },
      /**
       * Handle when the esc key is pressed.
       */
      _escKeydownHandler: function (event) {
        var ESC_KEYCODE = 27;
        if (event.keyCode === ESC_KEYCODE && !this.persistent) {
          event.preventDefault();
          this.close();
        }
      },
      /**
       * Handle re-calculating the layout and position.
       * @event px-drawer-reset-layout
       */
      resetLayout: function () {
        this.fire('px-drawer-reset-layout');
        //  console.warn(this.tagName, 'resetLayout');
      },
      /**
       * Handle when iron-resize event fires.
       */
      _resizeHandler: function () {
        this.resetLayout();
      },
      /**
       * Handle moving the drawer
       * @param translateX
       * @private
       */
      _moveDrawer: function(translateX) {
        var _content = this.$.drawer;
      //  this.transform(this._transformForTranslateX(translateX), _content);
      //  this.toggleClass('is-open', this.underlayOpened, _content);
        this.toggleClass('transition', this._transition, _content);
        this.toggleClass('dragging', this._dragging, _content);

      },
      /**
       * Handle transforming the element.
       * @param translateX
       * @returns {*}
       * @private
       */
      _transformForTranslateX: function(translateX) {
        if (translateX === null) {
          return 'translate3d(0, 0, 0)';
        }
        return 'translate3d(' + translateX + 'px, 0, 0)';
      }
    });
  </script>
</dom-module>
